<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>masonary layout</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js" defer></script>
</head>
<body>
  <div id="auth-section">
    <form id="login-form">
      <input type="text" id="username" placeholder="Username" required>
      <input type="password" id="password" placeholder="Password" required>
      <button type="submit">Login</button>
    </form>
    <button id="logout-btn" style="display:none;">Logout</button>
  </div>
  <div id="upload-section" style="display:none;">
    <form id="upload-form" enctype="multipart/form-data">
      <input type="file" id="image-input" name="image" accept="image/*" multiple required>
      <button type="submit">Upload Image(s)</button>
    </form>
  </div>
  <div id="drag-drop-zone" style="display:none;margin-bottom:18px;padding:36px 0;border:2px dashed var(--primary);border-radius:12px;text-align:center;color:var(--primary);font-size:18px;transition:background 0.2s;">
    <span>Drag &amp; drop images here to upload</span>
    <input type="file" id="drag-zone-file-input" accept="image/*" multiple style="display:none;">
  </div>
  <div id="delete-selected-section" style="display:none; margin-bottom: 15px;">
    <button id="delete-selected-btn" disabled>Delete Selected</button>
    <button id="add-tags-selected-btn" disabled>Add Tags to Selected</button>
    <button id="download-selected-btn" disabled>Download Selected</button>
  </div>
  <div id="gallery-controls" style="display:flex;align-items:center;gap:18px;margin-bottom:18px;">
    <div>
      <label for="sort-select" style="font-weight:bold;">Sort by:</label>
      <select id="sort-select" class="sort-select">
        <option value="date_desc">Date (Newest)</option>
        <option value="date_asc">Date (Oldest)</option>
        <option value="name_asc">Name (A-Z)</option>
        <option value="name_desc">Name (Z-A)</option>
        <option value="tag_asc">Tag (A-Z)</option>
        <option value="tag_desc">Tag (Z-A)</option>
      </select>
    </div>
    <div>
      <input id="image-search-input" type="text" placeholder="Search by tag or filename..." style="padding:6px 12px;border-radius:6px;border:1.5px solid var(--secondary);background:var(--background);color:var(--text);font-size:var(--font-size-md);width:220px;">
    </div>
  </div>
  <div class="masonry" id="masonry"></div>

  <div id="image-modal" class="image-modal hidden">
    <div class="image-modal-backdrop"></div>
    <div class="image-modal-content">
      <button class="image-modal-close" title="Close">&times;</button>
      <div class="image-modal-body">
        <img id="modal-image" src="" alt="Preview">
        <div class="image-modal-meta">
          <div><b>Filename:</b> <span id="modal-filename"></span></div>
          <div><b>Uploaded:</b> <span id="modal-date"></span></div>
          <div><b>Tags:</b>
            <span id="modal-tags"></span>
          </div>
          <div><b>Description:</b>
            <span id="modal-description"></span>
          </div>
        </div>
        <div id="modal-desc-edit-section" style="display:none;">
          <textarea id="modal-desc-input" rows="3"></textarea>
          <div style="margin-top:6px;display:flex;gap:10px;justify-content:flex-end;">
            <button id="modal-desc-cancel-btn" class="modal-action-btn" style="background:var(--secondary);color:var(--text);">Cancel</button>
            <button id="modal-desc-save-btn" class="modal-action-btn" style="font-weight:bold;">Save</button>
          </div>
        </div>
      </div>
      <div class="image-modal-actions" style="position:sticky;bottom:0;padding-bottom:8px;z-index:2;">
        <button id="modal-edit-tags-btn" class="modal-action-btn" style="display:none;">Edit Tags</button>
        <button id="modal-edit-desc-btn" class="modal-action-btn" style="display:none;">Edit Description</button>
        <a id="modal-download-btn" class="modal-action-btn" download target="_blank">Download</a>
        <button id="modal-delete-btn" class="modal-action-btn" style="display:none;">Delete</button>
      </div>
    </div>
  </div>

  <div id="theme-manager" class="theme-manager">
    <button id="theme-btn" class="theme-btn">🎨</button>
    <div id="theme-popup" class="theme-popup hidden">
      <h3>Theme Editor</h3>
      <div id="theme-list" class="theme-list"></div>
      <div class="theme-editor">
        <div class="theme-editor-header">
          <h4>Edit Theme</h4>
          <div class="theme-editor-actions">
            <button class="theme-editor-btn revert-btn" onclick="revertThemeChanges()" style="display: none;">Revert</button>
            <button class="theme-editor-btn save-btn" onclick="saveThemeChanges()" style="display: none;">Save Changes</button>
          </div>
        </div>
        <div class="theme-property">
          <label>Text Color</label>
          <input type="color" data-var="--text">
        </div>
        <div class="theme-property">
          <label>Background</label>
          <input type="color" data-var="--background">
        </div>
        <div class="theme-property">
          <label>Primary</label>
          <input type="color" data-var="--primary">
        </div>
        <div class="theme-property">
          <label>Secondary</label>
          <input type="color" data-var="--secondary">
        </div>
        <div class="theme-property">
          <label>Accent</label>
          <input type="color" data-var="--accent">
        </div>
        <div class="theme-property">
          <label>Delete Button</label>
          <input type="color" data-var="--delete">
        </div>
        <div class="theme-font-editor">
          <div class="theme-font-property">
            <label>Font Family</label>
            <select data-var="--font-family">
              <option value="Arial, sans-serif">Arial</option>
              <option value="'Roboto', sans-serif">Roboto</option>
              <option value="'Open Sans', sans-serif">Open Sans</option>
              <option value="'Helvetica Neue', sans-serif">Helvetica Neue</option>
            </select>
          </div>
          <div class="theme-font-property">
            <label>Base Font Size</label>
            <input type="number" data-var="--font-size-base" min="12" max="24" step="1">
          </div>
        </div>
      </div>
      <div class="theme-create">
        <input type="text" id="new-theme-name" placeholder="Theme name">
        <button onclick="saveCurrentTheme()">Save Theme</button>
      </div>
    </div>
  </div>

  <script>
    let msnry = null;
    let selectedImages = new Set();
    let loggedInGlobal = false;

    let tagModal = null;
    function showTagModal({ filenames, currentTags, allTags = [], onSave, images = [] }) {
      if (tagModal) tagModal.remove();
      tagModal = document.createElement('div');
      tagModal.className = 'tag-modal-overlay';

      let tagSets = images.length ? images.map(img => new Set(img.tags || [])) : [new Set(allTags)];
      let allTagList = images.length
        ? Array.from(new Set([].concat(...images.map(img => img.tags || []))))
        : [...allTags];
      let commonTags = images.length
        ? allTagList.filter(tag => tagSets.every(set => set.has(tag)))
        : [...allTags];

      let tagStates = {};
      allTagList.forEach(tag => {
        if (commonTags.includes(tag)) tagStates[tag] = 'checked';
        else tagStates[tag] = 'indeterminate';
      });

      function renderTagCheckboxes() {
        return allTagList.map(tag => {
          let state = tagStates[tag];
          let checked = state === 'checked' ? 'checked' : '';
          let indeterminate = state === 'indeterminate' ? 'data-indeterminate="true"' : '';
          return `
            <label style="display:inline-flex;align-items:center;margin:2px 8px 2px 0;font-size:14px;">
              <input type="checkbox" class="tag-checkbox" data-tag="${encodeURIComponent(tag)}" ${checked} ${indeterminate} style="margin-right:6px;">
              <span>${tag}</span>
            </label>
          `;
        }).join('');
      }

      tagModal.innerHTML = `
        <div style="background:var(--background);color:var(--text);padding:30px 24px;border-radius:12px;min-width:320px;box-shadow:0 4px 24px rgba(0,0,0,0.2);">
          <h3 style="margin-top:0;">Add/Edit Tags</h3>
          <div style="margin-bottom:16px;">
            <label style="font-size:15px;">Tags:</label>
            <div id="tag-checkbox-list" style="display:flex;flex-wrap:wrap;gap:6px 8px;margin:8px 0 8px 0;">
              ${renderTagCheckboxes()}
            </div>
            <div style="display:flex;gap:8px;">
              <input id="tag-input" type="text" style="flex:1;width:100%;padding:8px;border-radius:6px;border:1px solid var(--secondary);background:var(--background);color:var(--text);" placeholder="Add tag and press Enter">
              <button id="tag-add-btn" style="padding:6px 14px;border-radius:6px;background:var(--primary);color:var(--background);border:none;cursor:pointer;font-weight:bold;">Add</button>
            </div>
          </div>
          <div style="display:flex;gap:12px;justify-content:flex-end;">
            <button id="tag-cancel-btn" style="padding:6px 18px;border-radius:6px;background:var(--secondary);color:var(--text);border:none;cursor:pointer;">Cancel</button>
            <button id="tag-save-btn" style="padding:6px 18px;border-radius:6px;background:var(--primary);color:var(--background);border:none;cursor:pointer;font-weight:bold;">Save</button>
          </div>
        </div>
      `;
      document.body.appendChild(tagModal);

      function updateIndeterminate() {
        document.querySelectorAll('.tag-checkbox').forEach(cb => {
          const tag = decodeURIComponent(cb.dataset.tag);
          cb.indeterminate = tagStates[tag] === 'indeterminate';
        });
      }
      updateIndeterminate();

      document.getElementById('tag-checkbox-list').addEventListener('change', e => {
        if (e.target.classList.contains('tag-checkbox')) {
          const tag = decodeURIComponent(e.target.dataset.tag);
          tagStates[tag] = e.target.checked ? 'checked' : 'unchecked';
          updateIndeterminate();
        }
      });

      function addTagFromInput() {
        const input = document.getElementById('tag-input');
        let val = input.value.trim();
        if (!val) return;
        val.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!allTagList.includes(tag)) {
            allTagList.push(tag);
            tagStates[tag] = 'checked';
          }
        });
        input.value = '';
        document.getElementById('tag-checkbox-list').innerHTML = renderTagCheckboxes();
        updateIndeterminate();
      }
      document.getElementById('tag-add-btn').onclick = addTagFromInput;
      document.getElementById('tag-input').addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ',') {
          e.preventDefault();
          addTagFromInput();
        }
      });

      document.getElementById('tag-cancel-btn').onclick = () => tagModal.remove();
      document.getElementById('tag-save-btn').onclick = async () => {
        if (images.length > 1) {
          for (const img of images) {
            let updatedTags = new Set(img.tags || []);
            for (let tag of allTagList) {
              if (tagStates[tag] === 'checked') {
                updatedTags.add(tag);
              } else if (tagStates[tag] === 'unchecked') {
                updatedTags.delete(tag);
              }
            }
            await fetch(`/api/images/${img.filename}/tags`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + getToken()
              },
              body: JSON.stringify({ tags: Array.from(updatedTags) })
            });
          }
          await onSave();
        } else {
          const tags = allTagList.filter(tag => tagStates[tag] === 'checked');
          await onSave(tags);
        }
        tagModal.remove();
      };
    }

    function formatDate(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleString();
    }

    const imageModal = document.getElementById('image-modal');
    const modalImage = document.getElementById('modal-image');
    const modalFilename = document.getElementById('modal-filename');
    const modalDate = document.getElementById('modal-date');
    const modalTags = document.getElementById('modal-tags');
    const modalDownloadBtn = document.getElementById('modal-download-btn');
    const modalDeleteBtn = document.getElementById('modal-delete-btn');
    const modalEditTagsBtn = document.getElementById('modal-edit-tags-btn');
    const modalDescription = document.getElementById('modal-description');
    const modalEditDescBtn = document.getElementById('modal-edit-desc-btn');
    const modalDescEditSection = document.getElementById('modal-desc-edit-section');
    const modalDescInput = document.getElementById('modal-desc-input');
    const modalDescCancelBtn = document.getElementById('modal-desc-cancel-btn');
    const modalDescSaveBtn = document.getElementById('modal-desc-save-btn');
    let modalImageObj = null;

    function showImageModal(imgObj, loggedIn) {
      modalImageObj = imgObj;
      modalImage.src = imgObj.url;
      modalFilename.textContent = imgObj.filename;
      modalDate.textContent = imgObj.uploaded ? formatDate(imgObj.uploaded) : '';
      modalTags.innerHTML = '';
      if (imgObj.tags && imgObj.tags.length) {
        imgObj.tags.forEach(tag => {
          const tagEl = document.createElement('span');
          tagEl.className = 'image-tag-box';
          tagEl.textContent = tag;
          modalTags.appendChild(tagEl);
        });
      } else {
        modalTags.textContent = '(none)';
      }
      modalDownloadBtn.href = imgObj.url;
      modalDownloadBtn.download = imgObj.filename;
      modalEditTagsBtn.style.display = loggedIn ? '' : 'none';
      modalEditDescBtn.style.display = loggedIn ? '' : 'none';
      modalDeleteBtn.style.display = loggedIn ? '' : 'none';
      modalDescription.textContent = (imgObj.description && imgObj.description.trim()) ? imgObj.description : '(none)';
      modalDescription.style.display = '';
      modalDescEditSection.style.display = 'none';
      imageModal.classList.remove('hidden');
    }

    function hideImageModal() {
      imageModal.classList.add('hidden');
      modalImageObj = null;
    }

    document.querySelector('.image-modal-close').onclick = hideImageModal;
    document.querySelector('.image-modal-backdrop').onclick = hideImageModal;
    document.addEventListener('keydown', e => {
      if (!imageModal.classList.contains('hidden') && e.key === 'Escape') hideImageModal();
    });

    modalEditTagsBtn.onclick = () => {
      if (!modalImageObj) return;
      showTagModal({
        filenames: [modalImageObj.filename],
        currentTags: modalImageObj.tags,
        allTags: modalImageObj.tags,
        onSave: async (newTags) => {
          await fetch(`/api/images/${modalImageObj.filename}/tags`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + getToken()
            },
            body: JSON.stringify({ tags: newTags })
          });
          hideImageModal();
          loadImages();
        }
      });
    };

    modalEditDescBtn.onclick = () => {
      if (!modalImageObj) return;
      modalDescInput.value = modalImageObj.description || '';
      modalDescEditSection.style.display = '';
      modalEditDescBtn.style.display = 'none';
      modalDescription.style.display = 'none';
    };
    modalDescCancelBtn.onclick = () => {
      modalDescEditSection.style.display = 'none';
      modalEditDescBtn.style.display = '';
      modalDescription.style.display = '';
    };
    modalDescSaveBtn.onclick = async () => {
      if (!modalImageObj) return;
      const newDesc = modalDescInput.value.trim();
      await fetch(`/api/images/${modalImageObj.filename}/description`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + getToken()
        },
        body: JSON.stringify({ description: newDesc })
      });
      hideImageModal();
      loadImages();
    };

    let sortOption = 'date_desc';
    let allImages = [];
    let loadedCount = 0;
    const pageSize = 30;
    let loadingImages = false;
    let searchQuery = '';

    document.getElementById('sort-select').addEventListener('change', function() {
      sortOption = this.value;
      loadedCount = 0;
      document.getElementById('masonry').innerHTML = '';
      renderImagesWithInfiniteScroll(true);
    });

    document.getElementById('image-search-input').addEventListener('input', function() {
      searchQuery = this.value.trim().toLowerCase();
      loadedCount = 0;
      document.getElementById('masonry').innerHTML = '';
      renderImagesWithInfiniteScroll(true);
    });

    function sortImages(images, option) {
      let sorted = [...images];
      switch (option) {
        case 'date_desc':
          sorted.sort((a, b) => (b.uploaded || 0) - (a.uploaded || 0));
          break;
        case 'date_asc':
          sorted.sort((a, b) => (a.uploaded || 0) - (b.uploaded || 0));
          break;
        case 'name_asc':
          sorted.sort((a, b) => a.filename.localeCompare(b.filename));
          break;
        case 'name_desc':
          sorted.sort((a, b) => b.filename.localeCompare(a.filename));
          break;
        case 'tag_asc':
          sorted.sort((a, b) => {
            const ta = (a.tags && a.tags[0]) || '';
            const tb = (b.tags && b.tags[0]) || '';
            return ta.localeCompare(tb);
          });
          break;
        case 'tag_desc':
          sorted.sort((a, b) => {
            const ta = (a.tags && a.tags[0]) || '';
            const tb = (b.tags && b.tags[0]) || '';
            return tb.localeCompare(ta);
          });
          break;
      }
      return sorted;
    }

    function filterImages(images, query) {
      if (!query) return images;
      return images.filter(img => {
        const nameMatch = img.filename.toLowerCase().includes(query);
        const tagsMatch = (img.tags || []).some(tag => tag.toLowerCase().includes(query));
        return nameMatch || tagsMatch;
      });
    }

    async function loadImages() {
      const res = await fetch('/api/images');
      let images = await res.json();
      await Promise.all(images.map(async img => {
        try {
          const metaRes = await fetch(`/api/images-meta/${encodeURIComponent(img.filename)}`);
          if (metaRes.ok) {
            const meta = await metaRes.json();
            img.uploaded = new Date(meta.uploaded).getTime();
          }
        } catch {}
      }));
      allImages = images;
      loadedCount = 0;
      document.getElementById('masonry').innerHTML = '';
      renderImagesWithInfiniteScroll(true);
    }

    function renderImagesWithInfiniteScroll(reset = false) {
      if (loadingImages) return;
      loadingImages = true;
      // Filter images by search query
      let filtered = filterImages(allImages, searchQuery);
      const sorted = sortImages(filtered, sortOption);
      const masonry = document.getElementById('masonry');
      let start = loadedCount;
      let end = Math.min(loadedCount + pageSize, sorted.length);
      const imagesToRender = sorted.slice(start, end);
      loadedCount = end;
      if (reset) {
        masonry.innerHTML = '';
        loadedCount = imagesToRender.length;
      }
      renderImages(imagesToRender, loggedInGlobal, masonry, reset);
      loadingImages = false;
    }

    window.addEventListener('scroll', () => {
      if (loadingImages) return;
      const masonry = document.getElementById('masonry');
      if (
        window.innerHeight + window.scrollY >=
        (masonry.offsetTop + masonry.offsetHeight - 300)
      ) {
        if (loadedCount < allImages.length) {
          renderImagesWithInfiniteScroll();
        }
      }
    });

    function renderImages(images, loggedIn, masonryOverride = null, reset = false) {
      const masonry = masonryOverride || document.getElementById('masonry');
      const imageElements = [];
      images.forEach(imgObj => {
        const { url, filename, tags } = imgObj;
        const div = document.createElement('div');
        div.className = 'masonry-item';
        div.style.position = 'relative';

        let checkboxHtml = '';
        if (loggedIn) {
          checkboxHtml = `
            <input type="checkbox" class="select-checkbox" data-filename="${filename}" style="position:absolute;top:8px;left:8px;z-index:2;display:none;">
          `;
        }

        let tagHtml = '';
        if (tags.length) {
          tagHtml = `
            <div class="image-tags" style="position:absolute;left:8px;bottom:8px;z-index:2;display:flex;flex-direction:column;align-items:flex-start;gap:4px;pointer-events:none;opacity:0;transition:opacity 0.2s;">
              ${tags.map(t => `<div class="image-tag-box">${t}</div>`).join('')}
            </div>
          `;
        } else {
          tagHtml = `
            <div class="image-tags" style="position:absolute;left:8px;bottom:8px;z-index:2;display:flex;flex-direction:column;align-items:flex-start;gap:4px;pointer-events:none;opacity:0;transition:opacity 0.2s;"></div>
          `;
        }

        div.innerHTML = `
          ${checkboxHtml}
          <img src="${url}">
          ${tagHtml}
        `;

        const tagDiv = div.querySelector('.image-tags');
        div.addEventListener('mouseenter', () => {
          tagDiv.style.opacity = '1';
        });
        div.addEventListener('mouseleave', () => {
          tagDiv.style.opacity = '0';
        });

        if (loggedIn) {
          const checkbox = div.querySelector('.select-checkbox');
          if (selectedImages.has(filename)) {
            checkbox.checked = true;
            checkbox.style.display = 'block';
            div.classList.add('selected');
          }
          div.addEventListener('mouseenter', () => {
            checkbox.style.display = 'block';
          });
          div.addEventListener('mouseleave', () => {
            if (!checkbox.checked) checkbox.style.display = 'none';
          });
          checkbox.addEventListener('change', (e) => {
            if (checkbox.checked) {
              selectedImages.add(filename);
              checkbox.style.display = 'block';
              div.classList.add('selected');
            } else {
              selectedImages.delete(filename);
              checkbox.style.display = 'none';
              div.classList.remove('selected');
            }
            updateDeleteSelectedBtn();
            updateAddTagsSelectedBtn();
            updateDownloadSelectedBtn();
          });
        }

        if (loggedIn) {
          const btn = document.createElement('button');
          btn.innerHTML = '&times;';
          btn.className = 'delete-btn';
          btn.title = 'Delete';
          btn.onclick = () => deleteImage(filename);
          div.appendChild(btn);

          const downloadBtn = document.createElement('button');
          downloadBtn.innerHTML = '⬇️';
          downloadBtn.title = 'Download';
          downloadBtn.className = 'download-btn';
          downloadBtn.style.position = 'absolute';
          downloadBtn.style.top = '8px';
          downloadBtn.style.right = '48px';
          downloadBtn.style.zIndex = 3;
          downloadBtn.style.background = 'var(--primary)';
          downloadBtn.style.color = 'var(--background)';
          downloadBtn.style.border = 'none';
          downloadBtn.style.borderRadius = '50%';
          downloadBtn.style.width = '32px';
          downloadBtn.style.height = '32px';
          downloadBtn.style.fontSize = '18px';
          downloadBtn.style.cursor = 'pointer';
          downloadBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
          downloadBtn.style.transition = 'background var(--transition)';
          downloadBtn.onclick = (e) => {
            e.stopPropagation();
            downloadImages([filename]);
          };
          div.appendChild(downloadBtn);

          const tagEditBtn = document.createElement('button');
          tagEditBtn.innerHTML = '🏷️';
          tagEditBtn.title = 'Edit tags';
          tagEditBtn.className = 'tag-edit-btn';
          tagEditBtn.style.position = 'absolute';
          tagEditBtn.style.right = '8px';
          tagEditBtn.style.bottom = '8px';
          tagEditBtn.style.zIndex = 3;
          tagEditBtn.style.background = 'var(--primary)';
          tagEditBtn.style.color = 'var(--background)';
          tagEditBtn.style.border = 'none';
          tagEditBtn.style.borderRadius = '8px';
          tagEditBtn.style.padding = '2px 8px';
          tagEditBtn.style.fontSize = '15px';
          tagEditBtn.style.cursor = 'pointer';
          tagEditBtn.style.opacity = '0.85';
          tagEditBtn.style.transition = 'background 0.2s, color 0.2s';
          tagEditBtn.onmouseenter = () => tagEditBtn.style.opacity = '1';
          tagEditBtn.onmouseleave = () => tagEditBtn.style.opacity = '0.85';
          tagEditBtn.onclick = (e) => {
            e.stopPropagation();
            showTagModal({
              filenames: [filename],
              currentTags: tags,
              allTags: tags,
              onSave: async (newTags) => {
                await fetch(`/api/images/${filename}/tags`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + getToken()
                  },
                  body: JSON.stringify({ tags: newTags })
                });
                loadImages();
              }
            });
          };
          div.appendChild(tagEditBtn);
        }

        div.querySelector('img').onclick = async (e) => {
          let uploaded = '';
          let description = '';
          try {
            const res = await fetch(`/api/images-meta/${encodeURIComponent(filename)}`);
            if (res.ok) {
              const meta = await res.json();
              uploaded = meta.uploaded;
              description = meta.description || '';
            }
          } catch {}
          showImageModal({ ...imgObj, uploaded, description }, loggedIn);
        };

        masonry.appendChild(div);
        imageElements.push(div.querySelector('img'));
      });

      Promise.all(
        imageElements.map(img => {
          if (img.complete) return Promise.resolve();
          return new Promise(resolve => {
            img.onload = img.onerror = resolve;
          });
        })
      ).then(() => {
        if (msnry) msnry.destroy();
        msnry = new Masonry('.masonry', {
          itemSelector: '.masonry-item',
          columnWidth: '.masonry-item',
          gutter: 15,
          horizontalOrder: true
        });
      });
    }

    function updateDeleteSelectedBtn() {
      const btn = document.getElementById('delete-selected-btn');
      btn.disabled = selectedImages.size === 0;
    }
    function updateAddTagsSelectedBtn() {
      const btn = document.getElementById('add-tags-selected-btn');
      btn.disabled = selectedImages.size === 0;
    }
    function updateDownloadSelectedBtn() {
      const btn = document.getElementById('download-selected-btn');
      btn.disabled = selectedImages.size === 0;
    }

    async function loadImages() {
      const res = await fetch('/api/images');
      let images = await res.json();
      await Promise.all(images.map(async img => {
        try {
          const metaRes = await fetch(`/api/images-meta/${encodeURIComponent(img.filename)}`);
          if (metaRes.ok) {
            const meta = await metaRes.json();
            img.uploaded = new Date(meta.uploaded).getTime();
          }
        } catch {}
      }));
      allImages = images;
      loadedCount = 0;
      document.getElementById('masonry').innerHTML = '';
      renderImagesWithInfiniteScroll(true);
    }

    document.getElementById('login-form').onsubmit = async e => {
      e.preventDefault();
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      const res = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      if (res.ok) {
        const data = await res.json();
        localStorage.setItem('token', data.token);
        setAuthUI(true);
        loadImages();
      } else {
        alert('Login failed');
      }
    };

    document.getElementById('logout-btn').onclick = () => {
      localStorage.removeItem('token');
      setAuthUI(false);
      loadImages();
    };

    document.getElementById('upload-form').onsubmit = async e => {
      e.preventDefault();
      const fileInput = document.getElementById('image-input');
      if (!fileInput.files.length) return;
      const formData = new FormData();
      for (const file of fileInput.files) {
        formData.append('image', file);
      }
      const res = await fetch('/api/upload', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + getToken() },
        body: formData
      });
      if (res.ok) {
        fileInput.value = '';
        loadImages();
      } else {
        alert('Upload failed');
      }
    };

    const dragDropZone = document.getElementById('drag-drop-zone');
    const uploadSection = document.getElementById('upload-section');
    const dragZoneFileInput = document.getElementById('drag-zone-file-input');
    let dragCounter = 0;

    function showDropZone(show) {
      dragDropZone.style.display = show ? '' : 'none';
      if (!show) dragDropZone.classList.remove('dragover');
    }

    function isImageFile(file) {
      return file.type.startsWith('image/');
    }

    dragDropZone.addEventListener('dragover', e => {
      e.preventDefault();
      dragDropZone.classList.add('dragover');
    });
    dragDropZone.addEventListener('dragleave', e => {
      e.preventDefault();
      dragDropZone.classList.remove('dragover');
    });
    dragDropZone.addEventListener('drop', async e => {
      e.preventDefault();
      dragDropZone.classList.remove('dragover');
      showDropZone(false);
      const files = Array.from(e.dataTransfer.files).filter(isImageFile);
      if (!files.length) {
        showDropZone(true);
        return;
      }
      const formData = new FormData();
      files.forEach(file => formData.append('image', file));
      const res = await fetch('/api/upload', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + getToken() },
        body: formData
      });
      if (res.ok) {
        loadImages();
      } else {
        alert('Upload failed');
      }
      showDropZone(true);
    });

    dragDropZone.addEventListener('click', () => {
      if (dragZoneFileInput) dragZoneFileInput.click();
    });
    dragZoneFileInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files).filter(isImageFile);
      if (!files.length) return;
      const formData = new FormData();
      files.forEach(file => formData.append('image', file));
      const res = await fetch('/api/upload', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + getToken() },
        body: formData
      });
      if (res.ok) {
        loadImages();
      } else {
        alert('Upload failed');
      }
      dragZoneFileInput.value = '';
    });

    function setAuthUI(loggedIn) {
      document.getElementById('login-form').style.display = loggedIn ? 'none' : '';
      document.getElementById('logout-btn').style.display = loggedIn ? '' : 'none';
      document.getElementById('upload-section').style.display = loggedIn ? '' : 'none';
      document.getElementById('delete-selected-section').style.display = loggedIn ? '' : 'none';
      dragDropZone.style.display = loggedIn ? '' : 'none';
      loggedInGlobal = loggedIn;
      if (!loggedIn) {
        selectedImages.clear();
        updateDeleteSelectedBtn();
        updateAddTagsSelectedBtn();
        updateDownloadSelectedBtn();
      } else {
        updateDownloadSelectedBtn();
      }
    }

    document.addEventListener('dragenter', e => {
      if (!loggedInGlobal) return;
      dragCounter++;
      showDropZone(true);
      dragDropZone.classList.add('dragover');
    });
    document.addEventListener('dragleave', e => {
      if (!loggedInGlobal) return;
      dragCounter--;
      if (dragCounter <= 0) {
        showDropZone(false);
        dragCounter = 0;
      }
    });
    document.addEventListener('dragover', e => {
      if (!loggedInGlobal) return;
      e.preventDefault();
    });
    document.addEventListener('drop', e => {
      if (!loggedInGlobal) return;
      dragCounter = 0;
    });

    async function deleteImage(filename) {
      if (!confirm('Delete this image?')) return;
      const res = await fetch('/api/images/' + filename, {
        method: 'DELETE',
        headers: { 'Authorization': 'Bearer ' + getToken() }
      });
      if (res.ok) {
        selectedImages.delete(filename);
        updateDeleteSelectedBtn();
        loadImages();
      }
      else alert('Delete failed');
    }

    async function deleteSelectedImages() {
      if (selectedImages.size === 0) return;
      if (!confirm('Delete selected images?')) return;
      const filenames = Array.from(selectedImages);
      let failed = false;
      for (const filename of filenames) {
        const res = await fetch('/api/images/' + filename, {
          method: 'DELETE',
          headers: { 'Authorization': 'Bearer ' + getToken() }
        });
        if (!res.ok) failed = true;
      }
      selectedImages.clear();
      updateDeleteSelectedBtn();
      loadImages();
      if (failed) alert('Some images could not be deleted.');
    }

    document.getElementById('delete-selected-btn').onclick = deleteSelectedImages;

    document.getElementById('add-tags-selected-btn').onclick = async () => {
      if (selectedImages.size === 0) return;
      const res = await fetch('/api/images');
      const images = await res.json();
      const selected = images.filter(img => selectedImages.has(img.filename));
      let allTags = [];
      if (selected.length > 0) {
        const tagSet = new Set();
        selected.forEach(img => (img.tags || []).forEach(tag => tagSet.add(tag)));
        allTags = Array.from(tagSet);
      }
      showTagModal({
        filenames: Array.from(selectedImages),
        currentTags: [],
        allTags,
        images: selected,
        onSave: async () => {
          loadImages();
        }
      });
    };

    async function downloadImages(filenames) {
      if (!Array.isArray(filenames) || filenames.length === 0) return;
      const isSingle = filenames.length === 1;
      const res = await fetch('/api/download', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filenames })
      });
      if (!res.ok) {
        alert('Download failed');
        return;
      }
      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = isSingle ? filenames[0] : 'images.zip';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        window.URL.revokeObjectURL(url);
        a.remove();
      }, 100);
    }

    document.getElementById('download-selected-btn').onclick = () => {
      if (selectedImages.size === 0) return;
      downloadImages(Array.from(selectedImages));
    };

    function getToken() {
      return localStorage.getItem('token');
    }

    function setAuthUI(loggedIn) {
      document.getElementById('login-form').style.display = loggedIn ? 'none' : '';
      document.getElementById('logout-btn').style.display = loggedIn ? '' : 'none';
      document.getElementById('upload-section').style.display = loggedIn ? '' : 'none';
      document.getElementById('delete-selected-section').style.display = loggedIn ? '' : 'none';
      dragDropZone.style.display = loggedIn ? '' : 'none';
      loggedInGlobal = loggedIn;
      if (!loggedIn) {
        selectedImages.clear();
        updateDeleteSelectedBtn();
        updateAddTagsSelectedBtn();
        updateDownloadSelectedBtn();
      }
    }

    async function checkLogin() {
      const token = getToken();
      if (!token) {
        setAuthUI(false);
        loadImages();
        return;
      }
      const res = await fetch('/api/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token })
      });
      const data = await res.json();
      setAuthUI(data.valid);
      loadImages();
    }

    document.addEventListener("DOMContentLoaded", checkLogin);
  </script>
  <script>
    let originalThemeValues = {};

    document.getElementById('theme-btn').addEventListener('click', () => {
      document.getElementById('theme-popup').classList.toggle('hidden');
    });

    document.addEventListener('click', (e) => {
      const popup = document.getElementById('theme-popup');
      const btn = document.getElementById('theme-btn');
      if (!popup.contains(e.target) && !btn.contains(e.target)) {
        popup.classList.add('hidden');
      }
    });

    async function loadThemes() {
      try {
        const response = await fetch('/api/themes');
        const themes = await response.json();
        const themeList = document.getElementById('theme-list');
        themeList.innerHTML = themes.map(theme => `
          <div class="theme-item">
            <input type="text" class="theme-name-input"
              value="${theme.name}"
              onchange="updateThemeName(${theme.id}, this.value)"
              ${Number(theme.is_default) ? 'disabled' : ''}>
            <div class="theme-item-actions">
              <button onclick="applyTheme(${theme.id})" class="theme-apply">Apply Theme</button>
              ${!Number(theme.is_default) ? `<button onclick="deleteTheme(${theme.id}, event)" class="delete-btn">Remove</button>` : ''}
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading themes:', error);
      }
    }

    async function updateThemeName(id, newName) {
      if (!newName.trim()) return;
      try {
        const response = await fetch(`/api/themes/${id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName.trim() })
        });
        if (!response.ok) {
          const error = await response.json();
          alert(error.error);
          await loadThemes();
        }
      } catch (error) {
        console.error('Error updating theme name:', error);
        await loadThemes();
      }
    }

    function rgbToHex(color) {
      if (color.startsWith('#')) return color;
      const rgb = color.match(/\d+/g);
      if (!rgb) return '#000000';
      const r = parseInt(rgb[0]);
      const g = parseInt(rgb[1]);
      const b = parseInt(rgb[2]);
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    async function applyTheme(id) {
      try {
        const response = await fetch('/api/themes');
        const themes = await response.json();
        const theme = themes.find(t => t.id === id);
        if (!theme) return;
        const colors = JSON.parse(theme.colors);
        localStorage.setItem('activeThemeId', id);
        Object.entries(colors).forEach(([key, value]) => {
          document.documentElement.style.setProperty(`--${key}`, value);
        });
        document.querySelectorAll('.theme-property input[type="color"]').forEach(input => {
          const varName = input.dataset.var;
          if (varName) {
            const colorName = varName.substring(2);
            if (colors[colorName]) {
              input.value = rgbToHex(colors[colorName]);
            }
          }
        });
        document.querySelectorAll('.theme-font-property input, .theme-font-property select').forEach(input => {
          const varName = input.dataset.var;
          if (varName) {
            const propName = varName.substring(2);
            if (colors[propName]) {
              let value = colors[propName];
              if (input.type === 'number') {
                value = parseInt(value.replace('px', ''));
              }
              input.value = value;
            }
          }
        });
        originalThemeValues = {};
        document.querySelectorAll('[data-var]').forEach(input => {
          const varName = input.dataset.var;
          const computedValue = getComputedStyle(document.documentElement)
            .getPropertyValue(varName).trim();
          originalThemeValues[varName] = computedValue;
        });
        hideThemeButtons();
      } catch (error) {
        console.error('Error applying theme:', error);
      }
    }

    async function loadSavedTheme() {
      const savedThemeId = localStorage.getItem('activeThemeId');
      if (savedThemeId) {
        await applyTheme(parseInt(savedThemeId));
      }
    }

    function initThemeEditor() {
      const root = document.documentElement;
      const style = getComputedStyle(root);
      originalThemeValues = {};
      document.querySelectorAll('.theme-property input[type="color"]').forEach(input => {
        const varName = input.dataset.var;
        const color = style.getPropertyValue(varName).trim();
        input.value = rgbToHex(color);
        originalThemeValues[varName] = color;
        input.addEventListener('input', (e) => {
          root.style.setProperty(varName, e.target.value);
          showThemeButtons();
        });
      });
      document.querySelectorAll('.theme-font-property input, .theme-font-property select').forEach(input => {
        const varName = input.dataset.var;
        let value = style.getPropertyValue(varName).trim();
        if (input.type === 'number') {
          value = parseInt(value);
        }
        input.value = value;
        originalThemeValues[varName] = value;
        input.addEventListener('change', (e) => {
          let newValue = e.target.value;
          if (input.type === 'number') {
            newValue = `${newValue}px`;
          }
          root.style.setProperty(varName, newValue);
          showThemeButtons();
        });
      });
    }

    function showThemeButtons() {
      document.querySelector('.revert-btn').style.display = 'block';
      document.querySelector('.save-btn').style.display = 'block';
    }
    function hideThemeButtons() {
      document.querySelector('.revert-btn').style.display = 'none';
      document.querySelector('.save-btn').style.display = 'none';
    }
    function revertThemeChanges() {
      const root = document.documentElement;
      Object.entries(originalThemeValues).forEach(([varName, value]) => {
        root.style.setProperty(varName, value);
        const input = document.querySelector(`[data-var="${varName}"]`);
        if (input) {
          if (input.type === 'color') {
            input.value = rgbToHex(value);
          } else {
            input.value = input.type === 'number' ? parseInt(value) : value;
          }
        }
      });
      hideThemeButtons();
    }
    function saveThemeChanges() {
      const root = document.documentElement;
      const style = getComputedStyle(root);
      Object.keys(originalThemeValues).forEach(varName => {
        originalThemeValues[varName] = style.getPropertyValue(varName).trim();
      });
      hideThemeButtons();
    }
    async function saveCurrentTheme() {
      const name = document.getElementById('new-theme-name').value.trim();
      if (!name) {
        alert('Please enter a theme name');
        return;
      }
      const colors = {};
      document.querySelectorAll('[data-var]').forEach(input => {
        const varName = input.dataset.var.substring(2);
        let value = getComputedStyle(document.documentElement).getPropertyValue(input.dataset.var).trim();
        if (input.type === 'number') {
          value = value.replace('px', '') + 'px';
        }
        colors[varName] = value;
      });
      try {
        const response = await fetch('/api/themes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, colors })
        });
        if (!response.ok) {
          const error = await response.json();
          alert(error.error);
          return;
        }
        const result = await response.json();
        document.getElementById('new-theme-name').value = '';
        await loadThemes();
        await applyTheme(result.id);
      } catch (error) {
        console.error('Error saving theme:', error);
        alert('Failed to save theme');
      }
    }
    document.addEventListener('DOMContentLoaded', async () => {
      await loadThemes();
      await loadSavedTheme();
      initThemeEditor();
    });
    async function deleteTheme(themeId, event) {
      event.stopPropagation();
      if (!confirm('Are you sure you want to delete this theme?')) return;
      try {
        const response = await fetch(`/api/themes/${themeId}`, {
          method: 'DELETE'
        });
        if (!response.ok) {
          const error = await response.json();
          alert(error.error);
        } else {
          await loadThemes();
        }
      } catch (error) {
        console.error('Error deleting theme:', error);
        alert('Failed to delete theme');
      }
    }

    window.deleteTheme = deleteTheme;
    window.applyTheme = applyTheme;
    window.updateThemeName = updateThemeName;
  </script>
</body>
</html>